function context = cs(context,property,value,varargin)
%CS Writes value to context.property. property should be
%a string. For example, to write 1 to context.p.parameter, call 
%cs(context,'p.parameter',1).
%CS can write property data in two different ways:
% 1. When assumeStruct is true, CS will write the property value
%to a property struct (even if one must be created) after transforming it
%according to the information in the metadata and in the current context. 
%Be sure in this case that property is a property struct with the required
%metadata.
% 2. When assumeStruct is false, CS will write the
% raw value without transforming it. This technique allows one to access 
% metadata (for example).
%There are three different ways to call CS: 
%1. If CS is called with three arguments, current or default values will be
%used for transformType and assumeStruct will be assumed true.
%2. If CS is called with four arguments, the third argument will be 
%transformType and assumeStruct will still be assumed true.
%3. If CS is called with five arguments, the fourth argument will be
%assumeStruct. Be aware, though, that if assumeStruct is false
%transformType will not be utilized (so you should pass in a dummy
%argument).

%We first make sure that the property that we're trying to set doesn't have
%any active locks. A property has an active lock if its name or one of its
%namespaces' names is located in context.locks. For example, c.s.i.odeopts
%can be locked if 's', 's.i', or 's.i.odeopts' is located in context.locks.
%We want to be sure that if, for instance, 's' is locked then 'sa' will not
%be locked, so we split each property path and lock into cell arrays of
%names.
splitProperty = split(property,'.');
locks = getLocks(context);
for i = 1:numel(locks)
    splitLocks = split(locks{i},'.');
    
    %If the length of the lock is longer than the property, the lock can't
    %apply to the property.
    if numel(splitLocks) > numel(splitProperty)
        continue;
    end
    %Suppose a lock is 5 namespaces long. We compare the lock and the
    %property's namespaces 1:5, even if the property has a longer
    %namespace. If these two things are equal, the lock applies.
    if isequal(splitProperty(1:numel(splitLocks)),splitLocks)
        
        ME = MException('CMDS:locked', ...
        ['The property that you are trying to access is subject to one' ...
         ' or more active locks. Clear relevant locks and try again. '  ...
         'If this property is locked because caching is active, disable'...
         ' caching instead; doing so will clear appropriate locks while'...
         ' ensuring that function handles are recalculated properly. ' ...
         'Inversely, if you are attempting to a set a property in the '...
         'cache, turn']);
        throw(ME);
    end
end



%If there are exactly three arguments, we must find a value for
%transformType. We first attempt to find a version of the property that
%already exists; if we can find it, we retrieve the existing value of
%transformType. Otherwise, we use the default value, 1.
if nargin == 3
    %We ascertain whether a version of the property already exists so
    %that we can retrieve a default value of transformType.
    try
        existing = getfield_nested(context,property);
        transformType = existing.transformType;
    catch exception
        %If the field doesn't exist in the context, the property doesn't yet 
        %exist either yet. That's ok... it just means we might have to do some
        %things differently.
        if strcmp(exception.identifier, 'MATLAB:nonExistentField')
            %1 is the default value.
            transformType = 1;
        else
            rethrow(exception)
        end    
    end
    assumeStruct = true;

elseif nargin == 4
    transformType = varargin{1};
    assumeStruct = true;
elseif nargin >= 5
    transformType = varargin{1};
    assumeStruct = varargin{2};
end

if assumeStruct
   %Case 1 above
   prop_struct = csconvert(context,value,transformType);
   context = setfield_nested(context,property,prop_struct);
else
   %Case 2 above
   context = setfield_nested(context,property,value);
end

end
